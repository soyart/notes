tags:: Data structure

- # Graph theory
	- A study of networks of vertices (nodes), connected by edges
- # Properties
	- ## Direction
		- *Undirected graph* edge has no orientation, and the edge is usually denoted $(u, v)$ which means there's a connection between noode $u$ and $v$
		- For undirected graphs, edges $(u, v) = (v, u)$
		- If the edge has some orientation/direction, then we call it a *directed graph*
	- ## Weight
		- If the edge has some form of weight, then it's a weighted graph
		- Weight could be positive only, or sometimes a negative weight is allowed
		- For weighted graph, edge is usually denoted $(u, v, w)$
	- ## Cycle
		- A cyclic graph has nodes that can be reached again
		- A acyclic graph has no circles - once we visit a node, we can't reach it again
- # Problems
	- ## Find connectivity
		- Whether $node_i$ could be reachable by $node_j$
			- e.g. BFS or DFS
	- ## Find best routes
		- **Smallest hops** , **shortest path**, and **cheapest path**
			- e.g. BFS or DFS for unweighted graphs
			- e.g. Dijkstra, Bellman-Ford, Floyd-Marshall, A* for weighted graphs
	- ## Find cycles
		- ### Detect negative cycles
			- Negative cycles might be problematic - because we keep getting cheaper and cheaper paths. Some algo, e.g. Djikstra, prohibits negative weight
			- **Negative cycles are valid or even desirable in some use case**, e.g. finding currency swap arbitrage opportunities
				- For currency swap arbitrage, we could use the negative cycles such that we keep getting lower cost each time we cycle
			- e.g. Bellman-Ford and Floyd-Marshall
		- ### Detect strongly connected components (SSCs)
			- SSC is a self-contained cycle within a directed graph, where every node in the SSC can reach other nodes within the same SSC
			- Usually used in other higher-level algorithms
			- e.g. Tarjan and Kosaraju
	- ## Traveling salesman
		- Given a map of roads, distances, and cities, find the best route to visit each city exactly once and return to the origin city
		- e.g. Held-Karp, branch-and-bound, and other approximating algorithms
	- ## Find/cut bridges
		- Bridges are **edges**, whose removal increases number of *connected components*.
		  id:: 65ac10f4-6468-4618-b9df-062b347b40e0
			- A component in an undirected graph is its subgraph that is not connected to any other larger subgraphs
			- The image below depicts a graph with 3 components
			- ![GraphWith3Components](https://upload.wikimedia.org/wikipedia/commons/8/85/Pseudoforest.svg)
		- We can think of bridges as weak points, bottlenecks, etc.
	- ## Find/cut articulation points
		- Articulation points are vertices (nodes) whose removal increases the number of [connected components](((65ac10f4-6468-4618-b9df-062b347b40e0)))
- # Types of graphs
	- ## Tree
		- Trees are *acyclic undirected* graphs
		- > Any undirected graphs are trees in this sense, **although when we talk about trees we generally refer to the rootedd trees**
		- ### Rooted trees
			- Rooted trees are trees with root noode at the top
			- All nodes, except the root, can have only 1 parent
			- Trees are ubiquitous in CS, and some types of tree are in use almost everywhere, e.g. the [[Binary tree]] and [[B-Tree]]
			- Trees usually are graphs with $N$ nodes and $N-1$ edge
	- ## Directed acyclic graphs (DAG)
		- Directed graphs with no cycles
		- Usually used to describe dependencies
		- e.g. Apache Beam pipelines, college course prerequisites, booting OS, etc.
	- ## Bipartite graphs
		- Nodes can be spit into 2 independent groups $A$ and $B$
		- Every single edge connects a node from group $a$ to a node in group $b$
			- $(u, v \mid u \in A$ and $v \in b)$
		- Example use case is in network flows
	- ## Complete graphs
		- Each node has edges to all other nodes
		- Usually bad because they are very dense
	- # Types of graphs
- # Representing graphs
	- ## Adjacency matrix
		- Adjacency matrix $m$ is a matrix such that cell $m[i][j]$ represent edge between $node_i$ to $node_j$.
			- #### For unweighted graphs, the cell values could be $1$ (connection) or $0$ (no connection)
			- It is usually assumed that an edge going from a node to itself has value of $0$
			- #### For undirected graphs, the matrix is symmetric
				- $\begin{matrix} 0 & 1 & 0 \\ 1 & 0 & 1 \\ 0 & 1 & 0 \end{matrix}$
				  id:: 65ac017e-a33c-42f6-8b45-fda6d3b2b7b5
				- The above adjacency matrix represents undirected graph with 3 nodes $A$, $B$, and $C$
				- $B$ is connected to both $A$ and $C$, while $A$ and $C$ are connected
				- i.e. $E = \{(B, A), (B, C)\}$ and because this graph id undirected, we can say that edges $(B, A) = (A, B)$, and edges $(B, C) = (C, B)$
				  id:: 65ac03e2-2198-4b2c-8281-34b60f0380c0
			- #### For directed graphs, the matrix reflects the direction of the edge
				- $\begin{matrix} 0 & 0 & 0 \\ 1 & 0 & 1 \\ 0 & 0 & 0 \end{matrix}$
				- Using the [same example](((65ac03e2-2198-4b2c-8281-34b60f0380c0))), this is the resulting matrix where $A$ and $C$ goes to nowhere, but $B$ goes to both $A$ and $C$
				- i.e. $E = \{(B, A), (B, C)\}$
				  id:: 65ac0434-eb20-4553-8e81-78559f5178d4
			- #### For weighted graphs, the cell value $m[i][j]$ could be the weight value from $node_i$ to $node_j$
				- $\begin{matrix} 0 & 0 & 0 \\ 20 & 0 & 7 \\ 0 & 0 & 0 \end{matrix}$
				- Using the [same example of directed graph](((65ac0434-eb20-4553-8e81-78559f5178d4))), but this time, the edge $B$->$A$ has cost of 20, and edge $B$->$A$ has cost of 7
				- i.e. $E = \{(B, A, 20), (B, C, 7)\}$
		- **Nice for dense graphs**, because we can access edges in constant time
		- Bad for not-so-dense graphs
			- It takes $O(V^2)$ time to iterate through all edges
			- It requires $O(V^2)$ space for graphs with $V$ nodes
	- ## Adjacency list
		- Map list of edges to a node, e.g. using `map[node][]edges`in Go
			- For example, if we map the following graph as:
			- ```
			  A -> [(B, 10), (C, 2)]
			  B -> []
			  C -> [(B, 7)]
			  ```
			- This means that we have 3 edges: $(A, B, 10), (A, C, 2), (C, B, 7)$
		- **Nice for sparse graphs**, because we *only* store the edges we have
			- Good for iterating through all edges
		- **Bad for dense graphs**, because we now have to duplicate the edges
			- Edge lookup takes $O(E)$
	- ## Edge list
		- Represent graphs as unordered list of edges
		- Each edge is a triplet tuple $(u, v, w)$ or $(\text{from}, \text{to}, \text{weight})$
		- Very simple (lack any structure)
		- e.g. this list $\{(A, B, 1), (B, C, 2), (A, C, 7), (C, A, 3)\}$ for a directed graph with 3 nodes and 4 edges